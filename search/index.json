[{"content":"前言\r笔者有两年Java开发经验，目前需要临时用go语言开发一些功能，为了快速入手Go语言，在简单了解基础语法后，决定以实战来巩固知识。\n参考了《Rust圣经》的思路，决定先开发一个模仿grep的工具，来快速巩固基础语法、Go项目管理。\n为精简内容，本系列不包含环境搭建等基础部分（网上教程写的更清楚详细），直接讲解开发思路。希望能对后来者提供一些入门思路。\n笔者整体思路：大致了解go语言的语法，了解某个工具的大致功能、实现方法。然后再辅以AI语法提示（仅仅告诉某个细节，比如如何读取参数等，而不是直接让ai实现功能）。这样便能快速入门一个不算复杂的语言。\n正文\rgrep命令简介\rgrep是一个最初用于Unix操作系统的命令行工具。在给出文件列表或标准输入后，grep会对匹配一个或多个正则表达式的文本进行搜索，并只输出匹配（或者不匹配）的行或文本。\n\u0026ndash; wiki百科\ngrep的一个经典用法是：\n1 grep /data/test.txt searchContent 其中，/data/test.txt 是要搜索的文件列表， searchContent是我们要搜索的内容。这是一种最基本的功能。\n搭建基本框架\r我们的minigrep至少要先能获取到用户的目标 :文件列表及搜索内容 \u0026ndash; 即参数列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 读取参数列表 args := os.Args // 文件路径 filepath := args[1] // 搜索内容 searchText := args[2] content, e := os.ReadFile(filepath) if e != nil { panic(\u0026#34;Usage: illegal file name\u0026#34;) } // 假装已经实现了搜索功能 fmt.Printf(\u0026#34;search %s for file: %s\\n\u0026#34;, searchText, filepath) fmt.Printf(\u0026#34;file content: %s\\n\u0026#34;, string(content)) } 现在我们来运行一下：\n1 2 3 4 5 6 7 8 go run .\\main.go .\\data\\test1.txt 语言 search 语言 for file: .\\data\\test1.txt file content: Go 编程语言是一个开源项目，旨在提高程序员的生产力。 Go 表达力强、简洁、干净且高效。 其并发机制使编写能充分利用多核和联网机器的程序变得容易，而其新颖的类型系统则支持灵活且模块化的程序构建。 Go 可快速编译为机器代码，但具有垃圾回收的便利性和运行时反射的功能。 它是一种快速、静态类型、编译语言，但感觉像是一种动态类型、解释语言。 现在会打印search 语言 for file: .\\data\\test1.txt 以及完整的文件内容了，但是假如用户忘了输入他想要在哪个文件中搜索呢？\n1 2 3 4 5 6 7 PS D:\\go-project\\minigrep\u0026gt; go run .\\main.go 语言 panic: runtime error: index out of range [2] with length 2 goroutine 1 [running]: main.main() D:/go-project/minigrep/main.go:15 +0x185 exit status 2 oh no, 这是什么？我们作为开发人员当然能看懂这是什么，但是普通用户呢？因此我们除了需要真正实现搜索功能，还应该对这种异常情况做出更友好的提示。此外，我们所有的逻辑都杂糅在main方法中，这也不符合软件工程的最佳实践。\n初步重构，完成功能\r首先，我们需要将解析参数、读取文件内容、搜索内容这三个功能拆成不同的模块（func），此外，我们还得适当的处理panic。\n在java中，我们习惯用try-catch语法来捕获异常，再给出合理的错误提示。虽然go语言中也有类似的语法（recover），但是go语言更鼓励显式地处理这种预料之内的异常（即用func返回的error来判断）\n根据这些思路，我们写出了下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { args := os.Args filepath, searchText, err := parseArgs(args) if err != nil { fmt.Println(err) return } content, e := os.ReadFile(filepath) if e != nil { fmt.Println(e) return } searchFile(string(content), searchText) } func parseArgs(args []string) (filepath string, searchText string, error error) { if len(args) != 3 { return \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;illegal arguments, should be filepath and searchText\u0026#34;) } // 文件路径 filepath = args[1] searchText = args[2] return filepath, searchText, nil } func searchFile(content string, searchText string) { // go中string类型的空值是\u0026#34;\u0026#34;(空字符串)而不是nil if content == \u0026#34;\u0026#34; { return } lines := strings.Split(content, \u0026#34;\\n\u0026#34;) for _, line := range lines { if strings.Contains(line, searchText) { fmt.Println(line) } } } func readFile(filepath string) (string, error) { // 检查文件是否存在 if _, err := os.Stat(filepath); os.IsNotExist(err) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;file not found\u0026#34;) } // 检查是否是目录 info, err := os.Stat(filepath) if err == nil \u0026amp;\u0026amp; info.IsDir() { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;is a directory, not a file\u0026#34;) } // 读取文件内容 content, err := os.ReadFile(filepath) if err != nil { if os.IsPermission(err) { return \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;permission denied\u0026#34;) } return \u0026#34;\u0026#34;, err } return string(content), nil } 添加单元测试\r我们可以添加一些单元测试，用以初步验证我们的程序是否有错误。（以下测试代码用AI生成）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 package minigrep import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;testing\u0026#34; ) // TestParseArgs 测试解析命令行参数的功能 func TestParseArgs(t *testing.T) { // 保存原始的命令行参数 oldArgs := os.Args defer func() { os.Args = oldArgs }() // 测试正常情况 os.Args = []string{\u0026#34;minigrep\u0026#34;, \u0026#34;test.txt\u0026#34;, \u0026#34;hello\u0026#34;} filepath, searchText, err := parseArgs(os.Args) if err != nil { t.Errorf(\u0026#34;Expected no error, but got %v\u0026#34;, err) } if filepath != \u0026#34;test.txt\u0026#34; { t.Errorf(\u0026#34;Expected filepath to be \u0026#39;test.txt\u0026#39;, but got %v\u0026#34;, filepath) } if searchText != \u0026#34;hello\u0026#34; { t.Errorf(\u0026#34;Expected searchText to be \u0026#39;hello\u0026#39;, but got %v\u0026#34;, searchText) } // 测试参数数量错误的情况 os.Args = []string{\u0026#34;minigrep\u0026#34;, \u0026#34;test.txt\u0026#34;} _, _, err = parseArgs(os.Args) if err == nil { t.Error(\u0026#34;Expected error for incorrect number of arguments, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;illegal arguments\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;illegal arguments\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } } // TestSearchFile 测试在文件内容中搜索文本的功能 func TestSearchFile(t *testing.T) { // 测试包含搜索文本的情况 content := \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; searchText := \u0026#34;hello\u0026#34; expected := \u0026#34;hello world\\n\u0026#34; // 重定向标准输出以便捕获 r, w, _ := os.Pipe() stdout := os.Stdout os.Stdout = w searchFile(content, searchText) w.Close() os.Stdout = stdout // 读取输出 result, _ := io.ReadAll(r) if string(result) != expected { t.Errorf(\u0026#34;Expected output \u0026#39;%s\u0026#39;, but got \u0026#39;%s\u0026#39;\u0026#34;, expected, string(result)) } // 测试不包含搜索文本的情况 content = \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; searchText = \u0026#34;missing\u0026#34; r, w, _ = os.Pipe() stdout = os.Stdout os.Stdout = w searchFile(content, searchText) w.Close() os.Stdout = stdout // 读取输出 result, _ = io.ReadAll(r) if len(result) \u0026gt; 0 { t.Errorf(\u0026#34;Expected no output, but got \u0026#39;%s\u0026#39;\u0026#34;, string(result)) } } // TestReadFile 测试读取文件功能 func TestReadFile(t *testing.T) { // 创建临时测试文件 dir := t.TempDir() testFile := dir + \u0026#34;/test.txt\u0026#34; data := \u0026#34;hello world\\nthis is a test\\ngoodbye world\u0026#34; os.WriteFile(testFile, []byte(data), 0644) // 测试正常读取文件 content, err := readFile(testFile) if err != nil { t.Errorf(\u0026#34;Expected no error, but got %v\u0026#34;, err) } if content != data { t.Errorf(\u0026#34;Expected content \u0026#39;%s\u0026#39;, but got \u0026#39;%s\u0026#39;\u0026#34;, data, content) } // 测试读取不存在的文件 _, err = readFile(dir + \u0026#34;/nonexistent.txt\u0026#34;) if err == nil { t.Error(\u0026#34;Expected error for nonexistent file, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;file not found\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;file not found\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } // 测试读取目录 _, err = readFile(dir) if err == nil { t.Error(\u0026#34;Expected error for reading directory, but got none\u0026#34;) } else if !strings.Contains(err.Error(), \u0026#34;is a directory\u0026#34;) { t.Errorf(\u0026#34;Expected error message containing \u0026#39;is a directory\u0026#39;, but got \u0026#39;%v\u0026#39;\u0026#34;, err) } } 可以看到：我们的代码通过了测试\n1 2 3 4 5 6 7 8 9 PS D:\\go-project\\minigrep\u0026gt; go test -v === RUN TestParseArgs --- PASS: TestParseArgs (0.00s) === RUN TestSearchFile --- PASS: TestSearchFile (0.00s) === RUN TestReadFile --- PASS: TestReadFile (0.00s) PASS ok minigrep 0.160s 现在，我们可以放心将这个程序交给用户去使用啦（尽管功能简陋），但是我们要如何让用户能使用这个程序呢？\n打包为可执行文件\r我们可以用build命令打包为exe，以便用户在一个没有go语言环境的命令行中也能直接执行\n1 2 3 4 5 6 // 打包为exe go build -o minigrep.exe // 使用用例 PS D:\\go-project\\minigrep\u0026gt; .\\minigrep.exe .\\data\\test1.txt 功能 Go 可快速编译为机器代码，但具有垃圾回收的便利性和运行时反射的功能。 总结\r通过这个简短的程序，我们初步理解了golang中的func、异常处理、文件系统、赋值、流程控制、字符串处理等基础语法。然而，很多golang的特性、语法我们都没有涉及。此外，这个minigrep甚至不能称之为玩具，功能简陋至极。因此，在下一篇文章中，我们会逐步拓展功能，同时也会涉及更多新语法。\n","date":"2025-05-01T00:00:00Z","permalink":"http://localhost:1313/p/%E4%BA%94%E5%A4%A9%E9%80%9F%E9%80%9Ago%E4%B8%80--%E6%90%AD%E5%BB%BAmini-grep/","title":"五天速通go(一)--搭建mini-grep"}]